# coding: utf-8

"""
    Rustici Engine API

    Rustici Engine API  # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rustici_engine.api_client import ApiClient


class ContentConnectorsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_connector(self, body, **kwargs):  # noqa: E501
        """Create a connector  # noqa: E501

        Creates a connector for the specified tenant, or a system-wide connector if tenant is not specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_connector(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateConnectorSchema body: (required)
        :param str engine_tenant_name: optional tenant for this request
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_connector_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_connector_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_connector_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a connector  # noqa: E501

        Creates a connector for the specified tenant, or a system-wide connector if tenant is not specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_connector_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateConnectorSchema body: (required)
        :param str engine_tenant_name: optional tenant for this request
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'engine_tenant_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_connector" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_connector`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/contentConnectors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_connector_content_list(self, **kwargs):  # noqa: E501
        """Get list of available content  # noqa: E501

        Gets the list of content available, either for all connectors, or for only a specific connector if specified. If tenant is specified, this is the list of content for that tenant, if not, it is only content available through connectors configured for the whole system (not connectors configured for other tenants)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_connector_content_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: optional tenant for this request
        :param str connector_id: the connector id
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of lists, where needed. An opaque value, construction and parsing may change without notice.
        :param bool not_imported:
        :param str search:
        :param bool include_all_metadata:
        :return: ConnectorContentListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_connector_content_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_connector_content_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_connector_content_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of available content  # noqa: E501

        Gets the list of content available, either for all connectors, or for only a specific connector if specified. If tenant is specified, this is the list of content for that tenant, if not, it is only content available through connectors configured for the whole system (not connectors configured for other tenants)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_connector_content_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: optional tenant for this request
        :param str connector_id: the connector id
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of lists, where needed. An opaque value, construction and parsing may change without notice.
        :param bool not_imported:
        :param str search:
        :param bool include_all_metadata:
        :return: ConnectorContentListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'connector_id', 'since', 'more', 'not_imported', 'search', 'include_all_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_connector_content_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'connector_id' in params:
            query_params.append(('connectorId', params['connector_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'not_imported' in params:
            query_params.append(('notImported', params['not_imported']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'include_all_metadata' in params:
            query_params.append(('includeAllMetadata', params['include_all_metadata']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/contentConnectors/availableContent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorContentListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_connectors_list(self, **kwargs):  # noqa: E501
        """Get content connectors  # noqa: E501

        Gets list of connectors, for the specified tenant, or connectors that apply to all tenants if tenant is not specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_connectors_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: optional tenant for this request
        :return: ConnectorListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_connectors_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_connectors_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_connectors_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get content connectors  # noqa: E501

        Gets list of connectors, for the specified tenant, or connectors that apply to all tenants if tenant is not specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_connectors_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: optional tenant for this request
        :return: ConnectorListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_connectors_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/contentConnectors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_refresh_job_status(self, refresh_job_id, **kwargs):  # noqa: E501
        """Check the status of a refresh job.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_refresh_job_status(refresh_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str refresh_job_id: The Id received when the refresh job was submitted to the refreshJobs resource. (required)
        :param str engine_tenant_name: optional tenant for this request
        :return: RefreshConnectorResultListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_refresh_job_status_with_http_info(refresh_job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_refresh_job_status_with_http_info(refresh_job_id, **kwargs)  # noqa: E501
            return data

    def get_refresh_job_status_with_http_info(self, refresh_job_id, **kwargs):  # noqa: E501
        """Check the status of a refresh job.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_refresh_job_status_with_http_info(refresh_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str refresh_job_id: The Id received when the refresh job was submitted to the refreshJobs resource. (required)
        :param str engine_tenant_name: optional tenant for this request
        :return: RefreshConnectorResultListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refresh_job_id', 'engine_tenant_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_refresh_job_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'refresh_job_id' is set
        if ('refresh_job_id' not in params or
                params['refresh_job_id'] is None):
            raise ValueError("Missing the required parameter `refresh_job_id` when calling `get_refresh_job_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'refresh_job_id' in params:
            path_params['refreshJobId'] = params['refresh_job_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/contentConnectors/availableContent/refreshJobs/{refreshJobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RefreshConnectorResultListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_connector_content_list_job(self, **kwargs):  # noqa: E501
        """Start a job to refresh the list of available content  # noqa: E501

        Starts a job to refresh the list of content available, either for all connectors, or for only a specific connector if specified. If a tenant is specified, then this is this list of content for that tenant. If a tenant is not specified, then the list will only contain content available through connectors configured for the whole system (not connectors configured for other tenants)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_connector_content_list_job(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: optional tenant for this request
        :param str connector_id: the connector id
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.refresh_connector_content_list_job_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.refresh_connector_content_list_job_with_http_info(**kwargs)  # noqa: E501
            return data

    def refresh_connector_content_list_job_with_http_info(self, **kwargs):  # noqa: E501
        """Start a job to refresh the list of available content  # noqa: E501

        Starts a job to refresh the list of content available, either for all connectors, or for only a specific connector if specified. If a tenant is specified, then this is this list of content for that tenant. If a tenant is not specified, then the list will only contain content available through connectors configured for the whole system (not connectors configured for other tenants)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_connector_content_list_job_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: optional tenant for this request
        :param str connector_id: the connector id
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'connector_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_connector_content_list_job" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'connector_id' in params:
            query_params.append(('connectorId', params['connector_id']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/contentConnectors/availableContent/refreshJobs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_remote_connector_content(self, body, **kwargs):  # noqa: E501
        """search remote content  # noqa: E501

        Searches the remote content available, either for all connectors, or for only a specific connector if specified. If tenant is specified, this is the list of content for that tenant, if not, it is only content available through connectors configured for the whole system (not connectors configured for other tenants)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_remote_connector_content(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConnectorContentSearchSchema body: (required)
        :param str engine_tenant_name: optional tenant for this request
        :return: ConnectorContentListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_remote_connector_content_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.search_remote_connector_content_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def search_remote_connector_content_with_http_info(self, body, **kwargs):  # noqa: E501
        """search remote content  # noqa: E501

        Searches the remote content available, either for all connectors, or for only a specific connector if specified. If tenant is specified, this is the list of content for that tenant, if not, it is only content available through connectors configured for the whole system (not connectors configured for other tenants)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_remote_connector_content_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConnectorContentSearchSchema body: (required)
        :param str engine_tenant_name: optional tenant for this request
        :return: ConnectorContentListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'engine_tenant_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_remote_connector_content" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search_remote_connector_content`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/contentConnectors/remoteSearch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectorContentListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_connector(self, body, connector_id, **kwargs):  # noqa: E501
        """Update a connector  # noqa: E501

        Update the specified connector.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_connector(body, connector_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateConnectorSchema body: (required)
        :param str connector_id: the connector id (required)
        :param str engine_tenant_name: optional tenant for this request
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_connector_with_http_info(body, connector_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_connector_with_http_info(body, connector_id, **kwargs)  # noqa: E501
            return data

    def update_connector_with_http_info(self, body, connector_id, **kwargs):  # noqa: E501
        """Update a connector  # noqa: E501

        Update the specified connector.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_connector_with_http_info(body, connector_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateConnectorSchema body: (required)
        :param str connector_id: the connector id (required)
        :param str engine_tenant_name: optional tenant for this request
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'connector_id', 'engine_tenant_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_connector" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_connector`")  # noqa: E501
        # verify the required parameter 'connector_id' is set
        if ('connector_id' not in params or
                params['connector_id'] is None):
            raise ValueError("Missing the required parameter `connector_id` when calling `update_connector`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connector_id' in params:
            path_params['connectorId'] = params['connector_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/contentConnectors/{connectorId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
