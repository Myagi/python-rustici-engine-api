# coding: utf-8

"""
    Rustici Engine API

    Rustici Engine API  # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class CourseApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def build_course_preview_launch_link(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Returns the link to use to preview this course  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LaunchLinkRequestSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.build_course_preview_launch_link_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.build_course_preview_launch_link_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def build_course_preview_launch_link_with_http_info(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Returns the link to use to preview this course  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link_with_http_info(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LaunchLinkRequestSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'engine_tenant_name', 'course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method build_course_preview_launch_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `build_course_preview_launch_link`")  # noqa: E501
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `build_course_preview_launch_link`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `build_course_preview_launch_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/preview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LaunchLinkSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def build_course_preview_launch_link_with_version(self, body, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Returns the link to use to preview this course  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link_with_version(body, engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LaunchLinkRequestSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.build_course_preview_launch_link_with_version_with_http_info(body, engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.build_course_preview_launch_link_with_version_with_http_info(body, engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
            return data

    def build_course_preview_launch_link_with_version_with_http_info(self, body, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Returns the link to use to preview this course  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.build_course_preview_launch_link_with_version_with_http_info(body, engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LaunchLinkRequestSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :return: LaunchLinkSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'engine_tenant_name', 'course_id', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method build_course_preview_launch_link_with_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `build_course_preview_launch_link_with_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/preview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LaunchLinkSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_fetch_and_import_course_job(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Start a job to fetch and import a course.  # noqa: E501

        An import job will be started to fetch and import the referenced file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fetch_and_import_course_job(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ImportFetchRequestSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_fetch_and_import_course_job_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_fetch_and_import_course_job_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def create_fetch_and_import_course_job_with_http_info(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Start a job to fetch and import a course.  # noqa: E501

        An import job will be started to fetch and import the referenced file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fetch_and_import_course_job_with_http_info(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ImportFetchRequestSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'engine_tenant_name', 'course_id', 'may_create_new_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_fetch_and_import_course_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_fetch_and_import_course_job`")  # noqa: E501
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `create_fetch_and_import_course_job`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `create_fetch_and_import_course_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_upload_and_import_course_job(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Upload a course and start an import job for it.  # noqa: E501

        An import job will be started to import the posted file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_upload_and_import_course_job(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param str file:
        :param str uploaded_content_type: The MIME type identifier for the content to be uploaded
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_upload_and_import_course_job_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_upload_and_import_course_job_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def create_upload_and_import_course_job_with_http_info(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Upload a course and start an import job for it.  # noqa: E501

        An import job will be started to import the posted file, and the import job ID will be returned. If the import is successful, the imported course will be registered using the courseId provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_upload_and_import_course_job_with_http_info(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param str file:
        :param str uploaded_content_type: The MIME type identifier for the content to be uploaded
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :return: StringResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'file', 'uploaded_content_type', 'may_create_new_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_upload_and_import_course_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `create_upload_and_import_course_job`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `create_upload_and_import_course_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501
        if 'uploaded_content_type' in params:
            header_params['uploadedContentType'] = params['uploaded_content_type']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Delete `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def delete_course_with_http_info(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Delete `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_with_http_info(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `delete_course`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_configuration_setting(self, engine_tenant_name, course_id, setting_id, **kwargs):  # noqa: E501
        """Clears the `settingId` value for this course  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_configuration_setting(engine_tenant_name, course_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_configuration_setting_with_http_info(engine_tenant_name, course_id, setting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_configuration_setting_with_http_info(engine_tenant_name, course_id, setting_id, **kwargs)  # noqa: E501
            return data

    def delete_course_configuration_setting_with_http_info(self, engine_tenant_name, course_id, setting_id, **kwargs):  # noqa: E501
        """Clears the `settingId` value for this course  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_configuration_setting_with_http_info(engine_tenant_name, course_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'setting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_configuration_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `delete_course_configuration_setting`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_configuration_setting`")  # noqa: E501
        # verify the required parameter 'setting_id' is set
        if ('setting_id' not in params or
                params['setting_id'] is None):
            raise ValueError("Missing the required parameter `setting_id` when calling `delete_course_configuration_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'setting_id' in params:
            path_params['settingId'] = params['setting_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/configuration/{settingId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_version(self, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Delete version `versionId` of `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version(engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_version_with_http_info(engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_version_with_http_info(engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
            return data

    def delete_course_version_with_http_info(self, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Delete version `versionId` of `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_with_http_info(engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `delete_course_version`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_version`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `delete_course_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_course_version_configuration_setting(self, engine_tenant_name, course_id, version_id, setting_id, **kwargs):  # noqa: E501
        """Clears the `settingId` value for this course and version.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_configuration_setting(engine_tenant_name, course_id, version_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_course_version_configuration_setting_with_http_info(engine_tenant_name, course_id, version_id, setting_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_course_version_configuration_setting_with_http_info(engine_tenant_name, course_id, version_id, setting_id, **kwargs)  # noqa: E501
            return data

    def delete_course_version_configuration_setting_with_http_info(self, engine_tenant_name, course_id, version_id, setting_id, **kwargs):  # noqa: E501
        """Clears the `settingId` value for this course and version.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_course_version_configuration_setting_with_http_info(engine_tenant_name, course_id, version_id, setting_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :param str setting_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'version_id', 'setting_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_course_version_configuration_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `delete_course_version_configuration_setting`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `delete_course_version_configuration_setting`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `delete_course_version_configuration_setting`")  # noqa: E501
        # verify the required parameter 'setting_id' is set
        if ('setting_id' not in params or
                params['setting_id'] is None):
            raise ValueError("Missing the required parameter `setting_id` when calling `delete_course_version_configuration_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501
        if 'setting_id' in params:
            path_params['settingId'] = params['setting_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/configuration/{settingId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Get information about `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def get_course_with_http_info(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Get information about `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_with_http_info(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `get_course`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_configuration(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Returns all configuration settings for this course  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_configuration(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param bool include_metadata:
        :param bool include_hidden_settings: Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. 
        :param bool include_secret_settings: Should settings that are stored encrypted (type 'secretString') be included. Note: if included, the decrypted value will be returned. 
        :param bool process_replacement_tokens: Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements)
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_configuration_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_configuration_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def get_course_configuration_with_http_info(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Returns all configuration settings for this course  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_configuration_with_http_info(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param bool include_metadata:
        :param bool include_hidden_settings: Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. 
        :param bool include_secret_settings: Should settings that are stored encrypted (type 'secretString') be included. Note: if included, the decrypted value will be returned. 
        :param bool process_replacement_tokens: Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements)
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'include_metadata', 'include_hidden_settings', 'include_secret_settings', 'process_replacement_tokens']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `get_course_configuration`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'include_metadata' in params:
            query_params.append(('includeMetadata', params['include_metadata']))  # noqa: E501
        if 'include_hidden_settings' in params:
            query_params.append(('includeHiddenSettings', params['include_hidden_settings']))  # noqa: E501
        if 'include_secret_settings' in params:
            query_params.append(('includeSecretSettings', params['include_secret_settings']))  # noqa: E501
        if 'process_replacement_tokens' in params:
            query_params.append(('processReplacementTokens', params['process_replacement_tokens']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SettingListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_statements(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Get xAPI statements for `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_statements(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of lists, where needed. An opaque value, construction and parsing may change without notice.
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_statements_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_statements_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def get_course_statements_with_http_info(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Get xAPI statements for `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_statements_with_http_info(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of lists, where needed. An opaque value, construction and parsing may change without notice.
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'learner_id', 'since', 'until', 'more']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_statements" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `get_course_statements`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_statements`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'learner_id' in params:
            query_params.append(('learnerId', params['learner_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/xAPIStatements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='XapiStatementResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_configuration(self, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Returns all configuration settings for this course and version.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_configuration(engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :param bool include_metadata:
        :param bool include_hidden_settings: Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. 
        :param bool include_secret_settings: Should settings that are stored encrypted (type 'secretString') be included. Note: if included, the decrypted value will be returned. 
        :param bool process_replacement_tokens: Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements)
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_configuration_with_http_info(engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_configuration_with_http_info(engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_configuration_with_http_info(self, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Returns all configuration settings for this course and version.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_configuration_with_http_info(engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :param bool include_metadata:
        :param bool include_hidden_settings: Should settings that are declared to be hidden be included. Note: such settings generally do not need to be modified, and may be confusing. 
        :param bool include_secret_settings: Should settings that are stored encrypted (type 'secretString') be included. Note: if included, the decrypted value will be returned. 
        :param bool process_replacement_tokens: Whether to process replacement tokens (false returns the raw value of each setting, without tokens or environment variable replacements)
        :return: SettingListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'version_id', 'include_metadata', 'include_hidden_settings', 'include_secret_settings', 'process_replacement_tokens']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `get_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'include_metadata' in params:
            query_params.append(('includeMetadata', params['include_metadata']))  # noqa: E501
        if 'include_hidden_settings' in params:
            query_params.append(('includeHiddenSettings', params['include_hidden_settings']))  # noqa: E501
        if 'include_secret_settings' in params:
            query_params.append(('includeSecretSettings', params['include_secret_settings']))  # noqa: E501
        if 'process_replacement_tokens' in params:
            query_params.append(('processReplacementTokens', params['process_replacement_tokens']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SettingListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_info(self, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Get version `versionId` of `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_info(engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_info_with_http_info(engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_info_with_http_info(engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_info_with_http_info(self, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Get version `versionId` of `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_info_with_http_info(engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results
        :return: CourseSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'version_id', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `get_course_version_info`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_info`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_version_statements(self, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Get xAPI statements for version `versionId` of `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_statements(engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of lists, where needed. An opaque value, construction and parsing may change without notice.
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_version_statements_with_http_info(engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_version_statements_with_http_info(engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
            return data

    def get_course_version_statements_with_http_info(self, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Get xAPI statements for version `versionId` of `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_version_statements_with_http_info(engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :param str learner_id: Only entries for the specified learner id will be included.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param str more: Value for this parameter will be provided in the 'more' property of lists, where needed. An opaque value, construction and parsing may change without notice.
        :return: XapiStatementResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'version_id', 'learner_id', 'since', 'until', 'more']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_version_statements" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `get_course_version_statements`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_version_statements`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_course_version_statements`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []
        if 'learner_id' in params:
            query_params.append(('learnerId', params['learner_id']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/xAPIStatements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='XapiStatementResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_course_versions(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Get all versions of `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_versions(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results
        :return: CourseListNonPagedSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_course_versions_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_course_versions_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def get_course_versions_with_http_info(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Get all versions of `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_course_versions_with_http_info(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results
        :return: CourseListNonPagedSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'since', 'until', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_course_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `get_course_versions`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `get_course_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseListNonPagedSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_courses(self, engine_tenant_name, **kwargs):  # noqa: E501
        """Get a list of all courses for the specified tenant  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_courses(engine_tenant_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str more: Value for this parameter will be provided in the 'more' property of lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results
        :return: CourseListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_courses_with_http_info(engine_tenant_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_courses_with_http_info(engine_tenant_name, **kwargs)  # noqa: E501
            return data

    def get_courses_with_http_info(self, engine_tenant_name, **kwargs):  # noqa: E501
        """Get a list of all courses for the specified tenant  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_courses_with_http_info(engine_tenant_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str more: Value for this parameter will be provided in the 'more' property of lists, where needed. An opaque value, construction and parsing may change without notice.
        :param datetime since: Only items updated since the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param datetime until: Only items updated up until the specified ISO 8601 TimeStamp (inclusive) are included. If a time zone is not specified, UTC time zone will be used.
        :param bool include_registration_count: Include the registration count in the results
        :param bool include_course_metadata: Include course metadata in the results
        :return: CourseListSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'more', 'since', 'until', 'include_registration_count', 'include_course_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_courses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `get_courses`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'more' in params:
            query_params.append(('more', params['more']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'until' in params:
            query_params.append(('until', params['until']))  # noqa: E501
        if 'include_registration_count' in params:
            query_params.append(('includeRegistrationCount', params['include_registration_count']))  # noqa: E501
        if 'include_course_metadata' in params:
            query_params.append(('includeCourseMetadata', params['include_course_metadata']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CourseListSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_import_job_status(self, engine_tenant_name, import_job_id, **kwargs):  # noqa: E501
        """Check the status of an import job.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_job_status(engine_tenant_name, import_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str import_job_id: Id received when the import job was submitted to the importJobs resource. (required)
        :return: ImportJobResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_import_job_status_with_http_info(engine_tenant_name, import_job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_import_job_status_with_http_info(engine_tenant_name, import_job_id, **kwargs)  # noqa: E501
            return data

    def get_import_job_status_with_http_info(self, engine_tenant_name, import_job_id, **kwargs):  # noqa: E501
        """Check the status of an import job.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_job_status_with_http_info(engine_tenant_name, import_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str import_job_id: Id received when the import job was submitted to the importJobs resource. (required)
        :return: ImportJobResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'import_job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_job_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `get_import_job_status`")  # noqa: E501
        # verify the required parameter 'import_job_id' is set
        if ('import_job_id' not in params or
                params['import_job_id'] is None):
            raise ValueError("Missing the required parameter `import_job_id` when calling `get_import_job_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'import_job_id' in params:
            path_params['importJobId'] = params['import_job_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/importJobs/{importJobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImportJobResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_course_without_upload(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Create a course  # noqa: E501

        Import the specified course and return the results of the import. For large imports, it may be necessary to use importJobs instead to avoid timeouts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_course_without_upload(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ImportRequestSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param bool dry_run: Validate the course can be imported (mainly by validating the manifest), but don't actually import it.
        :return: ImportResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_course_without_upload_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.import_course_without_upload_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def import_course_without_upload_with_http_info(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Create a course  # noqa: E501

        Import the specified course and return the results of the import. For large imports, it may be necessary to use importJobs instead to avoid timeouts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_course_without_upload_with_http_info(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ImportRequestSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param bool dry_run: Validate the course can be imported (mainly by validating the manifest), but don't actually import it.
        :return: ImportResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'engine_tenant_name', 'course_id', 'may_create_new_version', 'dry_run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_course_without_upload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `import_course_without_upload`")  # noqa: E501
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `import_course_without_upload`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `import_course_without_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501
        if 'dry_run' in params:
            query_params.append(('dryRun', params['dry_run']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImportResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_configuration(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Set configuration settings for this course.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_configuration(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SettingsPostSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_configuration_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_configuration_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def set_course_configuration_with_http_info(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Set configuration settings for this course.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_configuration_with_http_info(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SettingsPostSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'engine_tenant_name', 'course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_course_configuration`")  # noqa: E501
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `set_course_configuration`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/configuration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_title(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Sets the course title for `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_title(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TitleSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_title_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_title_with_http_info(body, engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def set_course_title_with_http_info(self, body, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Sets the course title for `courseId`  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_title_with_http_info(body, engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TitleSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'engine_tenant_name', 'course_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_title" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_course_title`")  # noqa: E501
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `set_course_title`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_title`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/title', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_course_version_configuration(self, body, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Set configuration settings for this course and version.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_version_configuration(body, engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SettingsPostSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_course_version_configuration_with_http_info(body, engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_course_version_configuration_with_http_info(body, engine_tenant_name, course_id, version_id, **kwargs)  # noqa: E501
            return data

    def set_course_version_configuration_with_http_info(self, body, engine_tenant_name, course_id, version_id, **kwargs):  # noqa: E501
        """Set configuration settings for this course and version.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_course_version_configuration_with_http_info(body, engine_tenant_name, course_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SettingsPostSchema body: (required)
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: (required)
        :param int version_id: the course version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'engine_tenant_name', 'course_id', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_course_version_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `set_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `set_course_version_configuration`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params or
                params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `set_course_version_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['courseId'] = params['course_id']  # noqa: E501
        if 'version_id' in params:
            path_params['versionId'] = params['version_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/{courseId}/versions/{versionId}/configuration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_and_import_course(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Upload a course to import  # noqa: E501

        Upload and import the specified course and return the results of the import. For large imports, it may be necessary to use importJobs instead to avoid timeouts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_and_import_course(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param str file:
        :param str uploaded_content_type: The MIME type identifier for the content to be uploaded
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param bool dry_run: Validate the course can be imported (mainly by validating the manifest), but don't actually import it.
        :return: ImportResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_and_import_course_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_and_import_course_with_http_info(engine_tenant_name, course_id, **kwargs)  # noqa: E501
            return data

    def upload_and_import_course_with_http_info(self, engine_tenant_name, course_id, **kwargs):  # noqa: E501
        """Upload a course to import  # noqa: E501

        Upload and import the specified course and return the results of the import. For large imports, it may be necessary to use importJobs instead to avoid timeouts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_and_import_course_with_http_info(engine_tenant_name, course_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str engine_tenant_name: tenant for this request (required)
        :param str course_id: A unique identifier your application will use to identify the course after import. Your application is responsible both for generating this unique ID and for keeping track of the ID for later use. (required)
        :param str file:
        :param str uploaded_content_type: The MIME type identifier for the content to be uploaded
        :param bool may_create_new_version: Is it OK to create a new version of this course? If this is set to false and the course already exists, the upload will fail. If true and the course already exists then a new version will be created. No effect if the course doesn't already exist.
        :param bool dry_run: Validate the course can be imported (mainly by validating the manifest), but don't actually import it.
        :return: ImportResultSchema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['engine_tenant_name', 'course_id', 'file', 'uploaded_content_type', 'may_create_new_version', 'dry_run']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_and_import_course" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'engine_tenant_name' is set
        if ('engine_tenant_name' not in params or
                params['engine_tenant_name'] is None):
            raise ValueError("Missing the required parameter `engine_tenant_name` when calling `upload_and_import_course`")  # noqa: E501
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `upload_and_import_course`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('courseId', params['course_id']))  # noqa: E501
        if 'may_create_new_version' in params:
            query_params.append(('mayCreateNewVersion', params['may_create_new_version']))  # noqa: E501
        if 'dry_run' in params:
            query_params.append(('dryRun', params['dry_run']))  # noqa: E501

        header_params = {}
        if 'engine_tenant_name' in params:
            header_params['engineTenantName'] = params['engine_tenant_name']  # noqa: E501
        if 'uploaded_content_type' in params:
            header_params['uploadedContentType'] = params['uploaded_content_type']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/courses/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImportResultSchema',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
